## 레벨 1

### 약수의 개수와 덧셈 (77884)

- 접근방식 : left부터 right 수까지 차례대로 약수의 갯수를 counting하여 조건에 맞게 더하거나 빼기 진행.

- 다른 사람 풀이 접근방법 : 약수의 갯수가 홀 수 개인 정수의 경우 제곱근끼리 곱하여 정수가 되는 수학적 접근으로 진행
``` 16 의 경우 1,2,4,8,16으로 1*16, 2*8, 4*4로 대응된다. sqrt(16) * sqrt(16)이 16이 된다. 이에 반면 약수의 갯수가 짝 수개인 18을 예로 들면 1,2,3,6,9,18로 sqrt(18)*sqrt(18)은 18이 아니다. 이와 같은 수학적 접근방식으로도 문제 해결이 가능하다. 
```


### 문자열 내림차순으로 배치하기 (12917)
- 접근방식 : sort()와 sorted()의 인자로 들어가는 타입의 차이를 알고 있어서 문자열을 그대로 넣어서 정렬하기 위해 sorted()를 사용했다. sorted()를 사용하면 내장함수가 자체적으로 문자열을 리스트로 만들어서 정렬을 진행한다. 하지만 sort()함수 인자로는 무조건 리스트만 들어갈 수 있다. 

## 레벨 2

### 배열자르기 (87390)
- 정석대로 2중 for문을 활용해 배열을 다 만든 다음에 슬라이싱 진행 -> 시간초과 n의 값이 10^7로 매우 크기 때문에 이렇게 접근해선 안된다.
``` 애니메이션에 속아서 규칙을 뒤늦게 알게 됨 ```
- 규칙
 n이 3일 때,
1 2 3
2 2 3
3 3 3

이를 좌표로 나타내면 다음과 같다.
(0,0)  (0,1)  (0,2)
(1,0)  (1,1)  (1,2)
(2,0)  (2,1)  (2,2)

(x,y) 좌표 중 큰 값에 1을 더하면 해당 인덱스의 값이 된다는 규칙이 존재한다. ex  8번째 (2,1) 중 큰 값인 2에 1을 더하면 3이 나온다.


### 행렬의 곱셈 (12949)
- 행렬 곱의 순서에 맞춰서 3중 for loop를 진행시켰다. arr1의 행 갯수 -> arr2의 열 갯수 -> arr1의 열 갯수

- 다른 사람의 코드 

def solution(arr1, arr2):
    return [[sum(i*j for i, j in zip(row, col)) for col in zip(*arr2)] for row in arr1]

''' 리스트 앞에 *을 붙이면 unpacking을 할 수 있다. 쉽게 말해 대괄호([]) 하나를 벗겨내는 것이다.
arr2=[[5, 4, 3], [2, 4, 1], [3, 1, 1]]는 2차원 배열이었으므로 *arr2을 하면  [5, 4, 3] [2, 4, 1] [3, 1, 1]이 된다.
*arr2를 zip을 사용해 리스트들을 묶어주면, (5, 2, 3) (4, 4, 1) (3, 1, 1)로 같은 위치에 있는 요소들끼리 묶이게 된다.
(5, 2, 3) (4, 4, 1) (3, 1, 1)은 arr2에서 각 열에 해당하는 요소이므로 arr1의 행과 곱해주면 우리가 원하는 결과를 구할 수 있다.  '''
https://dduniverse.tistory.com/entry/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%ED%96%89%EB%A0%AC%EC%9D%98-%EA%B3%B1%EC%85%88-%ED%8C%8C%EC%9D%B4%EC%8D%AC-python


## 레벨 3
### 경주로건설
전형적인 BFS 문제임을 확인했고, 비용을 계속 트래킹하는 방법만 고안하면 해결될 것 같았다.
마지막 테스트케이스에서 목적지 경로가 한 개가 아니었기 때문에 출발방향을 구분지어서 적어도 두번 BFS를 동작시켜야한다고 생각함.
비용만 트래킹하는 그래프를 하나 만들어 다음 이동 방향에 조건을 걸어 비용을 산정하고 계속 업데이트하는 방식으로 진행.

### 입국심사
입국 기다리는 사람이 10억명이라는 걸 보자마자 이분탐색을 해야하는 문제임을 알았지만, 진행 방향에 손도 못댄 문제.
```
이분 탐색으로 문제를 해결할 때에는
start와 end의 값을 어떻게 설정할지, 그리고 구하고자 하는 값(mid) 가 무엇인지 고려해야 한다.
문제에서 원하는 것은 모든 사람이 심사를 받는데 걸리는 시간이므로 
start와 end 그리고 mid 모두 시간에 관련된 변수라고 짐작할 수 있다. 
입출력 예시로 생각해보자면, 

1 2 3 4 5 6 

6명의 각 사람들이 2명의 심사관에게 입국심사를 받게 되고 각 심사관은 7분, 10분이라는 시간을 소요한다. 
따라서 한 심사관이 심사하는데에 걸리는 최소시간은 1분, 최대 시간은 10 * 6 = 60분이라는 것을 알 수 있다. 
즉, start = 1 / end = 60 으로 설정해야 한다는 사실을 알 수 있다.  
탐색할 범위를 정해주었으므로 mid 값을 계속 바꾸며 최종 답을 얻기만 하면 된다. 
그렇다면 mid값을 어떻게 계속 변경해주어야 할까?
이 부분이 가장 생각하기 어려웠다. 

일단 모든 각 심사위원이 mid 시간 동안 몇명의 사람을 심사할 수 있는지 확인해야 한다. 
코드에서 total += mid // time 부분이 이것을 확인하는 부분이다. 
만약 주어진 n명보다 많이 심사할 수 있다면 더 확인할 필요가 없으므로 즉시 탐색 범위를 바꾸도록 해준다. 
주어진 n명보다 많이 심사할 수 있다면 mid값을 더 줄여야 한다. 따라서 end를 mid - 1로 바꿔준다. 
이때, 시간의 최솟값을 구하는 것이므로 mid 값을 계속해서 저장해준다. 
반대의 경우 mid 값을 증가시켜줘야 하므로 start를 mid + 1로 바꿔준다. 
이렇게 계속해서 mid 값을 바꿔가며 탐색하면 모든 사람을 심사하는 데에 걸리는 최솟값을 구할 수 있다.


## 백준
### 문자열 생성