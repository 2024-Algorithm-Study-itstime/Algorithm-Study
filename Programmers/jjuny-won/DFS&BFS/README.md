# DFS

- 깊이 우선 탐색
- 그래프는 노드와 간선으로 표현되며, 노드를 정점이라고도 말한다
- 두 노드가 간선으로 연결되어 있으면 '두 노드는 인접하다'라고 말한다
- 프로그래밍에서 그래프를 표현하는 방법 2가지
    1) 인접 행렬 :  2차원 배열로 그래프 연결 관계 표현하는 방식
    2) 인접 리스트 : 리스트로 그래프의 연결 관계 표현하는 방식
        - 모든 노드에 연결된 노드에 대한 정보를 차례대로 연결하여 저장한다
        - 연결 리스트 라는 자료구조를 이용해 구현한다
    - 두 방식의 차이점
        - 인접 행렬 방식은 노드 개수가 많을 수록 메모리 불필요하게 낭비된다
        - 인접 리스트 방식은 연결된 정보만을 저장하기 때문에 메모리 효율적으로 사용할 수 있다

- 동작 방법
    1. 탐색 시작 노드를 스택에 삽입하고 방문 처리한다
    2. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 그 인접 노드를 스택에 넣고 방문 처리 한다
        방문하지 않은 인접 노드가 없으면 최상단 노드에서 꺼낸다
    3. 2번의 과정을 수행할 수 있을 때까지 반복한다


# BFS

- 가까운 노드부터 탐색하는 알고리즘
- 선입 선출 (FIFO 방식) 방식인 큐 자료구조 이용
- 동작 방법
    1. 탐색 시작 노드를 큐에 삽입하고 방문 처리
    2. 큐에서 노드를 꺼내 인접노드 중에서 방문하지 않은 노드 모두 큐에 삽입 하고 방문 처리
    3. 2번의 과정을 수행할 수 없을 때까지 반복한다


--- 

# 문제 풀이

1. prog_42842

### 문제
- Leo가 본 카펫에서 갈색 격자의 수 brown, 노란색 격자의 수 yellow가 매개변수로 주어질 때 카펫의 가로, 세로 크기를 순서대로 배열에 담아 return 하도록 solution 함수를 작성해주세요.

### 접근 방법
- 갈색 격자의 수, 노란색 격자의 수의 관계를 파악했다 
- 노란색 격자의 약수의 조합 nxm 으로 나타낼 수 있을 때, (n+m+2)*2 == brown 처럼 표현되었다
- 격자와 너비와의 관계를 파악하였다.  (m+2,n+2)
- 관계를 조건문을 주어 해결하였다

### 아쉬운점
- 바로 DFS 라는 것은 떠올렸지만, 코드로 연결시키지는 못한 것 같다

### 참고해보면 좋을 것 같은 풀이

```
def solution(brown, red):
    for i in range(1, int(red**(1/2))+1):
        if red % i == 0:
            if 2*(i + red//i) == brown-4:
                return [red//i+2, i+2]

```


- 반복문 (for i in range(1, int(red**(1/2))+1)):
    red의 약수를 찾기 위해 1부터 red의 제곱근까지 반복합니다. 약수의 특성상 제곱근을 넘어가면 동일한 약수의 쌍이 반복되므로, 이 범위 내에서만 찾으면 됩니다.
- 내부 조건문 (if 2*(i + red//i) == brown-4):
카펫의 갈색 격자 수를 기반으로 가로와 세로 길이를 추론합니다.
    i와 red//i는 카펫의 내부(빨간색 격자) 가로와 세로 길이
    카펫의 전체 테두리(갈색 격자)는 2*(i + red//i + 2)입니다. 이때, +2는 각 측면의 테두리를 감안한 것입니다. 카펫의 갈색 격자는 빨간색 격자 주변을 한 격자씩 더 둘러싸기 때문에, 가로와 세로 각각에 2씩 추가됩니다.
    실제 갈색 격자 수는 brown = 2*(i + red//i + 2) + 4입니다. 여기서 +4는 모서리 격자 4개를 더하는 것을 의미합니다. 하지만 이 수식에서는 이를 제외하고 테두리만을 계산하므로 brown-4로 비교합니다.
- 반환문 (return [red//i+2, i+2]):
    카펫의 가로가 더 길거나 같기 때문에, 더 큰 약수 쪽이 가로가 됩니다.



2. prog_12985

### 문제
- 토너먼트 형식 게임에서 ,A번 참가자는 경쟁자로 생각하는 B번 참가자와 몇 번째 라운드에서 만나는지

### 접근 방법
- A,B가 라운두에서 맞붙을 때 : A = B+1 or B= A+1
- A=2,B=3 일 때 즉 다른 팀인데, 조건문에 부합하다고 인식할 때 : B 가 짝수일 때를 조건으로 추가
- 라운드 별 A,B의 번호를 보고 규칙 파악 n//2 

### 아쉬운점
- 시간 복잡도가 높고 코드가 복잡하다 -> 어떻게 하면 그렇게 간결하게 짤 수 있는지

### 참고해보면 좋을 것 같은 풀이
```

def solution(n,a,b):
    return ((a-1)^(b-1)).bit_length()

```


3. prog_42579 
### 문제
- 스트리밍 사이트에서 장르 별로 가장 많이 재생된 노래를 두 개씩 모아 베스트 앨범을 출시하려 합니다. 노래는 고유 번호로 구분하며, 노래를 수록하는 기준은 다음과 같습니다.

- 속한 노래가 많이 재생된 장르를 먼저 수록합니다.
- 장르 내에서 많이 재생된 노래를 먼저 수록합니다.
- 장르 내에서 재생 횟수가 같은 노래 중에서는 고유 번호가 낮은 노래를 먼저 수록합니다.
- 노래의 장르를 나타내는 문자열 배열 genres와 노래별 재생 횟수를 나타내는 정수 배열 plays가 주어질 때, 베스트 앨범에 들어갈 노래의 고유 번호를 순서대로 return 하도록 solution 함수를 완성하세요.

### 접근 방법
- { 장르 : 총 스트리밍 횟수 } 를 딕셔너리로 만든다
- 총 스트리밍 횟수가 많은 순으로 정렬 -> sorted_gen
- sorted_gen 순서대로 입력받은 genres 를 비교하며 해당하는 장르인 경우, 인덱스를 저장 -> 같은 장르끼리 인덱스 저장될 것
- 담은 인덱스를 바탕으로 해당 plays 값을 정렬해 answer에 담는다
- answer 를 2까지 확장한다 - 최대 2개 담을 수 있기 떄문

### 아쉬운점
- 조건문이 생겼을 때 조금 더 깔끔하게 처리하는 방법을 찾아봐야할 것 같다
- 코드가 복잡하고, 조건문이 너무 직관적으로 담긴다 
- 파이썬 함수를 제대로 사용하지 못했다

4. prog_64064 -> 미해결

### 문제
- 이벤트 응모자 아이디 목록이 담긴 배열 user_id와 불량 사용자 아이디 목록이 담긴 배열 banned_id가 매개변수로 주어질 때, 당첨에서 제외되어야 할 제재 아이디 목록은 몇가지 경우의 수가 가능한 지 return 하도록 solution 함수를 완성해주세요.


### 접근 방법
- answer 를 set으로 생성하여 중복되지 않도로 했다
- result 를 초기화할 때 banned_id의 수만큼 2차원리스트 생성하였다
- check 함수를 통해 각 문자별로 맞는지 확인하도록 구현
- 일치하는 아이디는 result 에 추가


- result를 바탕으로 가능한 조합을 구한다 -> product (이 부분부터 참고)
- 추가한 아이디를 set으로 중복을 없애고 길이를 비교하여 answer 추가

### 아쉬운점
- 조합을 사용하는 함수 활용 x
- 처음부터 너무 복잡하게 생각했다
- candidate 를 구하는 부분을 너무 어렵게 생각했다 
