# Dynamic Programming

# Level1

## prog_134240

### 문제
- 수웅이가 준비한 음식의 양을 칼로리가 적은 순서대로 나타내는 정수 배열 food가 주어졌을 때, 대회를 위한 음식의 배치를 나타내는 문자열을 return 하는 solution 함수를 완성해주세요.
- 준비한 음식의 수가 홀수 or 남을 경우 짝수개 까지만 표현

### 해결 방법
- i ==0 : 물의 경우 continue
- 1부터 food//2 개의 i 를 answer 에 추가
- 중간에 물 연결
- 마지막 상대편 선수는 문자열을 뒤집어서 연결

## prog_134240

### 문제
- 문자열 s가 주어졌을 때, s의 각 위치마다 자신보다 앞에 나왔으면서, 자신과 가장 가까운 곳에 있는 같은 글자가 어디 있는지 찾는문제
- s="banana" , 최종 결과물은 [-1, -1, -1, 2, 2, 2]

### 해결방법
- s 에서 for 문으로 하나씩 돌면서 s[i] 가 s[:i] 에 있을 때 -> 앞에 동일한 문자가 있을때
- 해당 인덱스에서 s[:i].rfind(s[i])를 빼준 값을 append 해주었다
- 만약에 동일한 문자가 없다면 -1 append

# Level2

## prog_49994 -> 미해결

### 문제
- 캐릭터를 4가지 명령어를 통해 움직인다
- 게임 캐릭처가 지나간 길 중에 처음 걸어본 길의 길이를 구하려한다

### 접근 방법
- dic로 각각의 방향에서 움직이는 경로를 지정
- for 문을 통해 해당방향에서 선언해놓은 경로를 따라 움직이도록
- boundart 를 검사

### 해결 못 한 이유
- 양방향성을 고려하지 못함
- 현재 코드에서 양방향성을 고려한다면 더욱 복잡해질 것

## prog_1844->미해결

### 문제
- ROR 게임은 두 팀으로 나누어서 진행하며, 상대 팀 진영을 먼저 파괴하면 이기는 게임입니다. 따라서, 각 팀은 상대 팀 진영에 최대한 빨리 도착하는 것이 유리합니다.
- 게임 맵의 상태 maps가 매개변수로 주어질 때, 캐릭터가 상대 팀 진영에 도착하기 위해서 지나가야 하는 칸의 개수의 최솟값을 return 하도록 solution 함수를 완성해주세요. 단, 상대 팀 진영에 도착할 수 없을 때는 -1을 return 해주세요.


### 접근 방법
- BFS 사용
- map 은 0 이고 길은 1
- 초기 값은 `(0, 0)`이고, 목표 지점은 `(len(maps) - 1, len(maps[0]) - 1)`

### 해결 못 한 이유
- BFS로 접근 및 구현의 어려움

# Level3

## prog_150365->미해결

### 문제
- n x m 격자 미로가 주어집니다. 당신은 미로의 (x, y)에서 출발해 (r, c)로 이동해서 탈출
- 이동하는 거리가 총 k
- 같은 격자를 두 번 이상 방문
- 미로에서 탈출한 경로를 문자열로 나타냈을 때, 문자열이 사전 순으로 가장 빠른 경로로 탈출

### 접근 방법
- 최소 거리를 맨해튼 거리로 계산
- 최소거리와 k 비교 -> impossible return
- l과 r을 n번해서 dx 의 값을 만들어야하고 
- u,d 을 (k-n) 번해서 dy 의 값을 만들어야 한다
- 그렇게 만들수 있는 경우수를 조합해서 이걸 사전순으로 가장 빠른 경로를 return 

### 해결 못 한 이유
- 이동하는 부분과 사전순을 고려하는 부분을 구현하지 못했다
- 또한 최소거리 외에 추가거리 구현에 어려움이 있었다

## prog_150367->미해결

### 문제
- 이진트리를 수로 표현
- 이진트리에서 리프 노드가 아닌 노드는 자신의 왼쪽 자식이 루트인 서브트리의 노드들보다 오른쪽에 있으며, 자신의 오른쪽 자식이 루트인 서브트리의 노드들보다 왼쪽에 있다고 가정합니다.
-> root 노드가 (서브 트리든 메인 트리든) 0 이면 이진트리를 만들 수 없다는 것 이용

### 접근 방법
- 각 요소가 binary 수로 변환
- 변환후 이진 탐색을 통해 반씩 나눠가면서 mid가 0 인지 (root 가 0인지) 확인

### 해결 못 한 이유
- 트리 구현의 어려움
- 문제 이해도 어려웠다

# 백준

## beak_1931

### 문제
 - N개의 회의에 대하여 회의실 사용표를 만들려고 한다.
 - 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수

### 접근 방법
- sort 로 끝나는 시간 기준으로 오름차순으로 정렬
- 2순위로 시작시간을 고려하도로 설정
- endtime을 설정하여 시작 시간과 비교해 count

### 어려웠던 부분
- 처음에 시작시간 고려하여 정렬 했을 때 시간 초과 발생
- 끝나는 시간만 고려했을 때 배열 생성시 순서가 잘못 고려 되었다